# Avoiding Common Attacks
This document lists some common Solidity smart contract attacks and the measures taken to ensure the Tender Submission Registry (TSR) is not susceptible. 


## Reentrancy
In a reentrancy attack, a function is called rapidly multiple times (e.g. using a script) and then performing transactions before the state such as a user balance is updated.

For TSR, the `registerTenderSubmission`, instead of updating tendersMap at the end, this is the first state object
to be updated before the `tendersAddressMap` mapping and `tenderHashes` array are updated. `tendersAddressMap` mapping and `tenderHashes`
are used for metadata / quick access purposes and should never be updated out of sync with `tendersMap` mapping, that would otherwise be akin to updating a users balance to zero (after sending money) as the last action in a function e.g. 2016 DAO hack which resulted in the forking of ETH and ETC. 

## Front-Running (AKA Transaction-Ordering Dependence)
Front-running can occur when maliscious users wait for transactions to be reflected in the mempool (i.e. the unconfirmed transactions) from which they can glean priviledged information / infer insights. Using this information, they send their own transactions with higher gasPrices. These transactions enter the the mempool and have a better chance of being included in a block as they have a higher gas price.
One way of solving this is to create a gas throttle - code in the contract that places an upper bound on gasPrice which in turn prevents users from increasing the gasPrice for their transactions and getting preferential transaction ordering beyond the upper-bound.  In the case of TSR, this is not a concern as TSR is not performing financial transfers. In addition, TSR is using the datetime from the Web Client.

## Block timestamp manipulation
Miners are capable of adjusting the block timestamps (~ range of about 30 seconds). As a result, it is better practise to use `block.number` instead of `block.timestamp`.
In the case of TSR, we make use of `block.number` as well as the datetime of a submission generated by the Web Client. 

## Integer Overflow and Underflow
Overflow/underflow happens when uints are incremented/decremented past their limit. The max value for a uint (i.e. uint256) is 2 ^ 256 – 1. If an integer increments past that number, it will overflow, and the value will go back to 0. 
Similarly, when a uint is reduced below zero, it will jump to it’s max value i.e. an underflow.
This can be prevented by reverting any function that is called that would have otherwise resulted in an overflow or an underflow.
In the case of TSR, the SafeMath library has been used for calculations.
